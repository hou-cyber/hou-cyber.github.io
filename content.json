{"pages":[],"posts":[{"title":"Linux-cuda安装","text":"cuda install 查看机器的的Driver Version，根据下面网址选择适合的cuda版本 https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html 进入cuda 链接 : https://developer.nvidia.com/cuda-toolkit-archive ​ 下载好cuda，使用runfile（较简单）的安装方式。 ​ 进入下载好的文件夹，输入：sudo sh cuda_10.0.130_410.48_linux.run 接下来会有一个warning，这是因为我们装cuda的时候没有选择安装驱动，不用管即可。 环境配置： 打开bashrc文件： 1sudo gedit ~/.bashrc 文件中添加如下语句： 123export PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64\\ ${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 保存关闭后source文件使配置生效: 1source ~/.bashrc 安装检验 1nvcc --version cudnn install 进入cudnn的下载网址：https://developer.nvidia.com/cudnn 选择适合的版本并下载： 进入cudnn的下载目录，解压文件： 1tar -xzvf cudnn-x.x-linux-x64-v8.x.x.x.tgz 解压完成之后将得到一个cuda文件夹。在当前目录执行以下命令： 123$ sudo cp cuda/include/cudnn*.h /usr/local/cuda/include $ sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda/lib64 $ sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* cuda不同版本切换 首先将先前添加到.bashrc里的环境变量路径全部指向cuda软链接，也就是环境变量的路径里所有cuda-x.0的名字都改成cuda： 1sudo gedit ~/.bashrc 删除原来的软链接： 1sudo rm -rf /usr/local/cuda 创建新的软链接: 1sudo ln -s /usr/local/cuda-10.2 /usr/local/cuda 验证操作，查看新的软链接的指向内容： 1sudo stat /usr/local/cuda","link":"/2021/11/20/Linux-cuda%E5%AE%89%E8%A3%85/"},{"title":"Linux-分区","text":"分区介绍​ 由于硬盘仅仅为分区表保留了64个字节的存储空间，而每个分区的参数占据16个字节，故主引导扇区中总计只能存储4个分区的数据。也就是说，一块物理硬盘只能划分为4个主分区磁盘。在具体的应用中，4个主分区磁盘往往不能满足实际需求。为了建立更多的磁盘分区供操作系统使用，引入了扩展分区和逻辑分区，并把原来的分区类型称为主分区。 ​ linux操作系统中，存储接口接入的存储设备显示为sda, sdb, sdc等等。 一块物理硬盘只能有 一到四个主分区*(但其中只能有一个是活动的主分区),或一到三个主分区, 和一个扩展分区。分别对应sda1,sda2,sda3,sda4.* 扩展分区是不能使用的，它只是做为逻辑分区的容器存在的，先创建一个扩展分区，在扩展分区之上创建逻辑分区；所有的逻辑分区都是扩展分区的一部分。 硬盘的容量=主分区的容量+扩展分区的容量； 扩展分区的容量=各个逻辑分区的容量之和。 磁盘管理命令：fdisk n: 添加新的分区 p: 查看分区信息 w: 保存退出 q: 不保存退出 d: 删除分区 t: 改变分区类型 演示 查看分区 1234567891011121314151617181920hyh@ubuntu:~$ sudo fdisk /dev/sdcWelcome to fdisk (util-linux 2.31.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): pDisk /dev/sdc: 894.3 GiB, 960197124096 bytes, 1875385008 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: dosDisk identifier: 0x022a5ac1Device Boot Start End Sectors Size Id Type/dev/sdc1 2048 1875384319 1875382272 894.3G 83 Linux # Device 是分区名称 Boot 是否是启动分区 Start 起始的扇区 End 结束的扇区 #size显示分区的空间；ld 为分区类型的ID号 Type 为分区类型 创建分区 12345678910Command (m for help): n #新建分区Partition type #分区类型 p primary (0 primary, 0 extended, 4 free) #p---&gt;主分区 e extended (container for logical partitions) #e---&gt;扩展分区Select (default p): p #选择主分区Partition number (1-4, default 1): 1First sector (2048-1953525167, default 2048): #分区磁盘的起始位，默认值，回车就好！Last sector, +sectors or +size{K,M,G,T,P} (2048-1953525167, default 1953525167): +5G #磁盘大小选择，加号不能省略，回车即可Created a new partition 1 of type 'Linux' and of size 5 GiB. LVM介绍​ LVM全称为Logical Volume Management，它是Linux环境下对磁盘分区进行管理的一种机制，它通过在硬盘和分区上建立一个抽象的逻辑层，来屏蔽分区大小，磁盘空间给用户带来的困难。在LVM中，可以将多个磁盘分区组做成一个存储池，管理员可以在此存储池上随意创建逻辑卷组，再mount到相应的挂载点上去，从而达成动态增加磁盘空间的目的。 物理块（Physical Extent）: 物理区域，PV中可以用于分配的最小存储单元，可以在创建PV的时候制定（默认为4MB），如1M, 2M, 4M, 8M, 32M, 64M…组成同一VG中所有PV的PE大小应该相同。 物理卷（PhysicalVolume）： PV创建于块设备上，块设备可以是整个磁盘、标准的分区、RAID和Linux RAID设备。 磁盘分区只有成为物理卷才可以加入卷组。物理卷是LVM的基本存储块。 卷组（Volume Group）： 卷组，建立在PV之上，可以含有一个到多个PV。类似于内存存储池。 逻辑卷(Logical Volume)： LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷上边可以建立文件系统，用于mount到不同的挂载点，提升分区空间——这是真正跟用户打交道的部分。 LVM创建​ 1.创建PV：物理磁盘或分区被格式化为PV，空间被划分为一个个的PE ​ 2.创建VG：不同的PV加入到同一个VG中，不同PV的PE全部进入到了VG的PE池内 ​ 3.创建LV：LV基于PE创建，大小为PE的整数倍，组成LV的PE可能来自不同的物理磁盘 ​ 4.创建文件系统及挂载：LV现在就直接可以格式化后挂载使用了 ​ 另外，LV的扩充缩减实际上就是增加或减少组成该LV的PE数量，如果操作正确其过程不会丢失原始数据 LVM命令 安装LVM apt-get install lvm2 信息查看 lvmdiskscan #显示LVM可能管理的所有可用块存储设备 df -h #文件系统查看 pvs 或 pvdisplay #查看物理卷 vgs 或 vgdisplay #查看卷组 lvs 或 lvdisplay #查看逻辑卷 创建物理卷PV pvcreate /dev/sda1 /dev/sda2 (有多个磁盘分区直接在后面添加，各分区用空格隔开) 创建卷组VG并添加物理卷PV vgcreate testvg(卷组名称) /dev/sdb1 /dev/sdb2 (有多个物理卷，在后面直接加上，用空格隔开) 如果存在卷组，只需要把把物理卷加入卷组即可，如： vgextend testvg /dev/sdb3 在卷组上创建逻辑卷LV sudo lvcreate -L +12G -n lv-root ubuntu -L 参数后跟的是你要设定的逻辑卷大小，这个大小必须是是你设定的PE值的整数倍 -l 后面跟的是PE数量 -n 参数后跟逻辑卷名字，是对创建的卷组命名 最后跟的是卷组名 为创建好的逻辑卷创建文件系统 mkfs.ext4 /dev/testvg/lv-root 逻辑卷挂载 Linux下的文件系统需要被挂载后才能使用，我们创建一个空目录，再把创建好的逻辑卷挂载上就可以使用了。 mount /dev/testvg/lv-root /disk1 LVM的扩容 卷组的扩容 vgextend 逻辑卷的扩容 lvextend -L +1G /dev/testvg/lv-root vextend -l +100%FREE /dev/testvg/lv-root（将卷组中的剩余所有空闲空间扩展到逻辑卷） 更新文件系统 resize2fs /dev/testvg/lv-root 或在扩容逻辑卷的同时加上-r参数他会自动扩展文件系统大小 LVM的缩小 逻辑卷扩容可以在线操作但是缩减必须是离线执行 先卸载已挂载的逻辑卷，缩减后注意再次挂载 umount /disk1/ 缩小文件系统 resize2fs /dev/testvg/lv-root 1G 缩小逻辑卷 lvreduce -L -1G /dev/testvg/lv-root 缩小卷组 缩小VG卷组也就是把一个PV从卷组中移除，但我们要先肯定PV中没有数据，不然就会造成数据的丢失。 vgreduce testvg /dev/sdb3 移除物理卷 相当于让分区又重新变成了普通分区 pvremove /dev/sdb3 参考：https://blog.51cto.com/u_13438667/2084924","link":"/2021/11/25/Linux-%E5%88%86%E5%8C%BA/"},{"title":"Pytorch中的数据处理","text":"​ 在pytorch中，一般将torch.utils.data.Dataset和torch.utils.data.DataLoader搭配来提供训练和测试时的数据。 ​ 一般为，先创建一个torch.utils.data.Dataset对象，再将之传递给torch.utils.data.DataLoader来完成数据的iteration读取。 Dataset​ 在dataloader支持两种类型的dataset（map-style dataset，iterable-style dataset），我们用的一般都是第一种，意味着给出key值，能够返回对应的数据和标签。例如 访问dataset[idx]，就可以获取对应的image和label。 ​ 首先利用torch.utils.data.Dataset抽象类来定义自己的数据集，需要重写该类中的三个基本方法。 123__init__ 初始化，定义数据内容和标签;__getitem__ 得到数据内容和标签,即返回给你一组你要的数据（input,target）;__len__ 返回数据集的长度 DataLoader​ 构建可迭代的数据集装载器，可以理解为一个迭代器，每次返回一组（input,target）数据。 12345torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=None, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None, multiprocessing_context=None, generator=None, *, prefetch_factor=2, persistent_workers=False)其中，batch_size 批大小shuffle 每个epoch的数据是否需要重新调整数据drop_last 不足batch大小的最后部分是否舍去 ​ 每个epoch都会执行一次DataLoader，在执行DataLoader时，会进入到dataset中的__ getitem __方法来获得（input,target）。 数据处理​ DataLoader在读取数据时会调用dataset中的__ getitem __方法，所以一般对data的处理（比如归一化，剪裁，类型转化，数据增强，从图像变成tensor等）都是在该方法中进行。 123456789101112131415161718192021def __init__(self, image_root, gt_root, edge_root,trainsize): ....... self.augumentation = transforms.Compose([ transforms.RandomHorizontalFlip(), transforms.RandomVerticalFlip(), transforms.RandomRotation(degrees=(-180,180)) ])def __getitem__(self, index): ....... seed = np.random.randint(2147483647) # make a seed with numpy generator random.seed(seed) # apply this seed to img tranfsorms torch.manual_seed(seed) # needed for torchvision 0.7 image = self.augumentation(image) random.seed(seed) # apply this seed to target tranfsorms torch.manual_seed(seed) # needed for torchvision 0.7 gt = self.augumentation(gt) return image, gt ​ 正如上面的代码，一般会在__ getitem __ 方法中对数据进行增强处理，而增强方式（翻转、旋转等）会在__ init __方法中定义（主要使用torchvision.transforms中已写好的一些操作）。 ​ 需要注意的是为了input和label能够同步进行数据增强，需要使用 random.seed(seed)和torch.manual_seed(seed) 来设置随机数生成器的种子。 12345678910111213141516171819202122232425#random.seed(seed) 会使random.random() 每次生成的随机数是一样的&gt;&gt;&gt;random.seed(4)&gt;&gt;&gt;random.random()0.23604808973743452 #(1)&gt;&gt;&gt;random.random()0.1031660342307158 #(2)&gt;&gt;&gt;random.seed(4)&gt;&gt;&gt;random.random()0.23604808973743452 #结果与（1）相同&gt;&gt;&gt;random.random()0.1031660342307158 #结果与（2）相同#torch.manual_seed(seed) 会使torch.rand() 每次生成的随机数是一样的&gt;&gt;&gt;import torch&gt;&gt;&gt;torch.manual_seed(4)&lt;torch._C.Generator object at 0x00000191D60ABD10&gt;&gt;&gt;&gt;torch.rand(2)tensor([0.5596, 0.5591]) #（1）&gt;&gt;&gt;torch.rand(2)tensor([0.0915, 0.2100]) #（2）&gt;&gt;&gt;torch.manual_seed(4)&lt;torch._C.Generator object at 0x00000191D60ABD10&gt;&gt;&gt;&gt;torch.rand(4)tensor([0.5596, 0.5591, 0.0915, 0.2100]) #结果与[(1) (2)]相同 ​ 所以，为什么既要使用 random.seed(seed)，又要torch.manual_seed(seed) ？ 123456789101112131415161718192021class RandomHorizontalFlip(object): ..... def __call__(self, img): if torch.random() &lt; self.p: #不同版本torchvision可能不同 return F.hflip(img) return img class RandomVerticalFlip(object): ...... def __call__(self, img): if torch.random() &lt; self.p: #不同版本torchvision可能不同 return F.vflip(img) return imgclass RandomRotation(object): ...... def get_params(degrees): angle = random.uniform(degrees[0], degrees[1]) #使用的是random的随机函数 return angle","link":"/2021/11/24/Pytorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"title":"Linux安装Matlab2020b","text":"linux安装Matlab2020b mkdir matlab2020 创建临时文件夹matlab2020 sudo mount -t auto -o loop Download/R2020a_Linux.iso matlab2020/ 挂载Downloade文件夹下的安装镜像R2020b_Linux.iso到创建的matlab2020文件夹下即可。 sudo ./matlab2020/install（即在matlab2020目录下执行sudo ./install）执行安装文件。中间需要输入用学校邮箱注册的账号密码，登录账户名一定要选工作站的用户名，不然后期要重新添加用户，中间/usr/local/bin/记得勾选上。安装时把工具包全选上 umount matlab2020/ #卸载光盘镜像 sudo rm -r matlab2020/ # 删除空文件夹 matlab在命令行直接输入matlab即可运行程序 12注：在进行第三步之前一定要联网，不然不会出现用学校邮箱登录画面。 第三部中的登录用户名一定要写自己的用户名(即Linux登录时的用户名)，因为只有这个指定的用户能用这个软件(即一个校园邮箱的激活码只能用于一个用户，其余方式的不清楚)，不过写错了也没关系，进行激活即可 若不能正常打开，进行激活账户cd /usr/local/MATLAB/R2020b/bin（即进入安装路径的bin目录） sh activate_matlab.sh ​ 若有多个matlab，可进入想要用的matlab的安装目录下的bin文件(默认安装目 录usr/local/MATLAB/R2020b)，执行 ./matlab(./的原因为防止他调用默认的matlab)。 gcc安装​ matlab下编译c文件，可在matwork上查找对应版本应该安装的gcc版本,要选择c++编译器时，要再安装g++(版本号最好和gcc一样，g++安装和gcc大同小异) 123sudo apt-get install gcc-4.8 安装4.8版本的gccsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100 将安装好的gcc版本放入gcc列表中，并设置优先级为100sudo update-alternatives --config gcc 将想用版本的gcc设置为默认gcc","link":"/2021/11/20/Linux%E5%AE%89%E8%A3%85Matlab2020b/"},{"title":"Ubuntu_install_cuda","text":"Ubuntu cuda\\cudnn install 10.0cuda install 查看机器的的Driver Version，根据下面网址选择适合的cuda版本 https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html 进入cuda 链接 : https://developer.nvidia.com/cuda-toolkit-archive 下载好cuda，使用runfile（较简单）的安装方式。 ​ 进入下载好的文件夹，输入：sudo sh cuda_10.0.130_410.48_linux.run ​ 接下来会有一个warning，这是因为我们装cuda的时候没有选择安装驱动，不用管即可。 环境配置： 打开bashrc文件： 1sudo gedit ~/.bashrc 文件中添加如下语句： 123export PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64\\ ${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 保存关闭后source文件使配置生效: 1source ~/.bashrc 安装检验 1nvcc --version cudnn install 进入cudnn的下载网址：https://developer.nvidia.com/cudnn 选择适合的版本并下载： 进入cudnn的下载目录，解压文件： 1tar -xzvf cudnn-x.x-linux-x64-v8.x.x.x.tgz 解压完成之后将得到一个cuda文件夹。在当前目录执行以下命令： 123$ sudo cp cuda/include/cudnn*.h /usr/local/cuda/include $ sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda/lib64 $ sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* cuda不同版本切换 首先将先前添加到.bashrc里的环境变量路径全部指向cuda软链接，也就是环境变量的路径里所有cuda-x.0的名字都改成cuda： 1sudo gedit ~/.bashrc 删除原来的软链接： 1sudo rm -rf /usr/local/cuda 创建新的软链接: 1sudo ln -s /usr/local/cuda-10.2 /usr/local/cuda 验证操作，查看新的软链接的指向内容： 1sudo stat /usr/local/cuda","link":"/2021/11/30/Ubuntu-install-cuda/"},{"title":"Linux-命令","text":"Linux 常用命令 chmod -R 777 /home/user 注：表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx chmod 777 /home/user 注：仅把/home/user目录的权限设置为rwxrwxrwx gedit 文件路径 注：以窗口形式打开文件 ifconfig 注：查看网络配置，windows下为ipconfig。 nautilus FloderName 打开指定目录的图形化窗口界面。 解压.zip 123unzip xxxxx.zip 把文件解压到当前目录下unzip file.zip -d destination_folder 把文件解压到指定的目录下(-d指定目标路径,file.zip是需要解压的，destination_folder是指定的目录下)。zip -r FileName.zip DirName 将指定目录下的所有文件和子目录一并压缩 挂载 12sudo mount /dev/sdb1 /mnt 挂载磁盘到某一路径sudo umount /dev/sdb1 卸载磁盘 进程 12ps -A 查看当前有哪些进程kill 5 位进程号 结束进程 用户 1234567sudo adduser username 新添加用户passwd username 修改密码sudo vim /etc/sudoers 赋予新用户 root 权限（找到root ALL=(ALL) ALL，在下一行添加username ALL=(ALL) ALL ）chmod u+rwx g+r o+r filename 用户添加读写运行权限，组成员添加读权限，其他用户添加读权限chmod a+w filename 所有用户添加写权限chmod 777 filename 所有用户添加读写运行权限 软件 12345678sudo apt-get upgrade 更新软件sudo apt-get install software-name 安装在软件库中的软件sudo apt-get remove 卸载软件sudo apt-get purge 卸载软件并删除配置文件sudo dpkg -i *.deb 安装 deb 软件dpkg -l 查看所有安装的软件sudo dpkg -i *.deb 安装 deb 软件dpkg -l 查看所有安装的软件 文件操作 123456789101112131415cd 切换目录，～为家目录，/为根目录，./为当前目录cd .. 切换到上级目录cd - 切换到上一次所在的目录pwd 查看当前所在目录ls 查看当前目录下的文件夹和文件名，-a显示隐藏文件，-l显示文件详细信息mkdir directory-name 新建文件夹rmdir directory-name 删除文件夹(必须为空)rm -rf directory-name 强制并递归删除文件夹cp src-file dst-file 复制文件mv src-file dst-file 移动文件ln -s src-file dst-file 建立软链接find path -name string 查找路经所在范围内满足字符串匹配的文件和目录cat filename 显示文件内容head -n 2 filename 显示文件前两行的内容tail -n 2 filename 显示文件末尾两行的内容 系统信息 123cat /proc/versionuname -asb_release -a","link":"/2021/11/23/Linux-%E5%91%BD%E4%BB%A4/"},{"title":"带限制的子序列和","text":"题目描述​ 给你一个整数数组 nums 和一个整数 k ，请你返回非空子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和~满足 i &lt; j 且 j - i &lt;= k 。 1数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 示例 示例1： 123输入：nums = [10,2,-10,5,20], k = 2输出：37解释：子序列为 [10, 2, 5, 20] 。 示例2： 123输入：nums = [-1,-2,-3], k = 1输出：-1解释：子序列必须是非空的，所以我们选择最大的数字。 示例3： 123输入：nums = [-1,-2,-3], k = 1输出：-1解释：子序列必须是非空的，所以我们选择最大的数字。 提示 1 &lt;= k &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 链接：https://leetcode-cn.com/problems/constrained-subsequence-sum/ 思路 类型：动态规划 + 单调队列优化 实现：循环、双向队列 分析：求子序列和的最大值，比较容易想到的是动态规划。建立数组dp，dp[i]表示以第i个元素结尾的子序列的最大值（注意：该子序列中要包含第i个元素）。状态转移方程为：$$dp[i]=\\max (dp[j])+nums[i]，其中 \\max(i-k, 0) \\leq j&lt;i$$需要注意的是只用动态规划会超时，既要进行优化。看状态转移方程发现，对于dp[i]每次要寻找前k个dp[j]的最大值，时间复杂度为k。因此，该题难点在于如何优化该寻找时间，这其实又是求滑动窗口最大值问题。 代码 c++ 动态规划：会超时。时间复杂度：O(nk) 1234567891011121314151617class Solution {public: int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) { if(nums.empty()){ return 0; //空数组，返回0 } vector&lt;int&gt; dp(nums.begin(), nums.end()); //建dp数组，用nums初始化，即刚开始最大值都为自己 int result = nums[0]; //记录dp数组中的最大值 for(int i = 1; i &lt; nums.size(); i++){ //求dp[1] -&gt; dp[max] for(int j = 1; j &lt;= k &amp;&amp; i - j &gt;= 0; j++){ //dp[i]状态转移方程 dp[i] = max(dp[i - j] + nums[i], dp[i]); } result = max(result, dp[i]); //更新result } return result; }}; 动态规划 + 单调队列优化 时间复杂度：O(n) 123456789101112131415161718192021222324252627282930class Solution {public: int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) { if(nums.empty()){ return 0; } vector&lt;int&gt; dp(nums.begin(), nums.end()); int result = nums[0]; deque&lt;int&gt; que; //建立双向队列 que.push_back(0); for(int i = 1; i &lt; nums.size(); i++){ while(i - que.front() &gt; k){ //若队首元素超过滑动窗口范围，pop que.pop_front(); } dp[i] = max(dp[que.front()] + nums[i], dp[i]); result = max(result, dp[i]); while(!que.empty() &amp;&amp; dp[i] &gt;= dp[que.back()]){ //若队尾元素小于dp[i]，pop que.pop_back(); } que.push_back(i); //将i插入队尾 } return result; }};","link":"/2021/11/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"},{"title":"替换单词","text":"题目描述在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。 需要输出替换之后的句子。 示例 示例1： 12输入：dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;输出：&quot;the cat was rat by the bat&quot; 示例2： 12输入：dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], sentence = &quot;aadsfasf absbs bbab cadsfafs&quot;输出：&quot;a a b c&quot; 示例3： 12输入：dictionary = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;], sentence = &quot;a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa&quot;输出：&quot;a a a a a a a a bbb baba a&quot; 提示 1 &lt;= dictionary.length &lt;= 1000 1 &lt;= dictionary[i].length &lt;= 100 dictionary[i] 仅由小写字母组成。 1 &lt;= sentence.length &lt;= 10^6 sentence 仅由小写字母和空格组成。 sentence 中单词的总量在范围 [1, 1000] 内。 sentence 中每个单词的长度在范围 [1, 1000] 内。 sentence 中单词之间由一个空格隔开。 sentence 没有前导或尾随空格。 链接：https://leetcode-cn.com/problems/UhWRSj/ 思路 类型：字典树 实现：树（孩子兄弟表示法） 解析：暴力法会超时，可以建立字典树。大概操作为： 使用dictionary来建立字典树。 将句子sentence分割为一个个单词。 对于每个单词，查询字典树，看是否进行替换。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution {public: //树的孩子兄弟表示法 struct node{ char val; node* son; //孩子结点指针 node* next; //兄弟结点指针 node(char c): val(c), son(NULL), next(NULL){} }; //判断单词str在不在字典树中，若在，则返回字典中对应的单词，否则返回str，即不做改变 string successor(string str){ node* curr = forest -&gt; son; if(curr == NULL){ return str; } for(int i = 0; i &lt; str.size(); i++){ if(curr == NULL){ return str.substr(0, i); } while(curr != NULL &amp;&amp; curr -&gt; val != str[i]){ curr = curr -&gt; next; } if(curr == NULL){ return str; }else{ curr = curr -&gt; son; } } return str; } //字典树 node* forest; string replaceWords(vector&lt;string&gt;&amp; dictionary, string sentence) { forest = new node(0); //初始根结点 //根据dictionary建立字典树 for(auto str : dictionary){ node* curr = forest; str = successor(str); for(int i = 0; i &lt; str.size(); i++){ node* father = curr; curr = curr -&gt; son; while(curr != NULL &amp;&amp; curr -&gt; val != str[i]){ curr = curr -&gt; next; } if(curr == NULL){ curr = father -&gt; son; father -&gt; son = new node(str[i]); father -&gt; son -&gt; next = curr; curr = father -&gt; son; }else{ if(i == str.size() - 1){ curr -&gt; son = NULL; } } } } string result; string temp; vector&lt;string&gt; ve; stringstream input(sentence); //读取str到字符串流中 //将句子sentence以空格为间隔分割为单词 while(getline(input, temp, ' ')) { ve.push_back(temp); } //单词替换 result = successor(ve[0]); for(int i = 1; i &lt; ve.size(); i++){ result = result + ' ' + successor(ve[i]); } return result; }};","link":"/2021/12/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D/"},{"title":"滑动窗口最大值","text":"题目描述​ 给你一个整数数组 nums，有一个大小为~的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 ​ 返回滑动窗口中的最大值。 示例 示例1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例2： 12输入：nums = [1], k = 1输出：[1] 示例3： 12输入：nums = [1,-1], k = 1输出：[1,-1] 示例4： 12输入：nums = [9,11], k = 2输出：[11] 提示 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 链接：https://leetcode-cn.com/problems/sliding-window-maximum/ 思路 类型：单调队列 || 大根堆 实现：双端队列（deque） || 优先队列（priority_queue） 知识点： 大根堆：其满足父节点值不小于子节点的值，即根节点记录的是树的最大值。所以可以用O(1)的时间取得最大值，插入和删除的时间复杂度为O(long(n))。STL中优先队列（priority_queue）的底层就是用堆来实现了。 在窗口滑动时，只需维护两个操作，即看堆顶的结点是否在该窗口内，若不在则弹出。将单词结点插入到队中。因为要对队首和队尾都进行操作，所以采用双端队列（deque） 来实现。 单调队列：是一种具有单调性的队列，主要用于解决滑动窗口类问题。用单调递减队列求滑动窗口最大值是，其应满足： 1231. 单调递减队列维护的是区间的最大值。2. 队列单调递减。不管是单调递减还是递增队列，其下标必须是递增的，这样才能滑动。3. 队首为最大值，队尾为当前结点。即遍历时，当前结点必须入队。 在窗口滑动时，只需维护两个操作，即从对尾开始将小于当前结点的所有结点出队，并将当前结点插入到队尾。从队首将不在窗口内的结点出队。因为要对队首和队尾都进行操作，所以采用双端队列（deque） 来实现。 代码 C++大根堆（用priority_queue实现）123456789101112131415161718192021222324252627282930313233343536373839struct node { int val; int index; node(int x, int y):val(x),index(y) {} //重载运算符 bool operator &lt; (node b) const{ return val &lt; b.val; }};class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { priority_queue&lt;node&gt; q; vector&lt;int&gt; results; //使用第一个窗口来初始化堆 for (int i = 0; i &lt; k; ++i) { node temp(nums[i], i); q.push(temp); } results.push_back(q.top().val); for (int i = k; i &lt; nums.size(); i++) { //当前结点插入堆中 node temp(nums[i], i); q.push(temp); //如果堆的顶点不在当前窗口内，弹出 while (i - q.top().index &gt;= k) { q.pop(); } results.push_back(q.top().val); } return results; }}; 单调队列123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt; que; //单调递减队列 vector&lt;int&gt; results; //记录滑动窗口的最大值 if(k == 1){ return nums; } que.push_back(0); //初始单调队列（第一个窗口） for(int i = 1; i &lt; k &amp;&amp; i &lt; nums.size(); i++){ while(!que.empty() &amp;&amp; nums[i] &gt;= nums[que.back()]){ que.pop_back(); } que.push_back(i); } results.push_back(nums[que.front()]); for(int i = k; i &lt; nums.size(); i++){ //如果队首的顶点不在当前窗口内，弹出 while(i - que.front() &gt;= k){ que.pop_front(); } //求该窗口的最大值，更新results if(nums[i] &gt; nums[que.front()]){ results.push_back(nums[i]); }else{ results.push_back(nums[que.front()]); } //从队尾开始将小于nums[i]的所有结点弹出 while(!que.empty() &amp;&amp; nums[i] &gt;= nums[que.back()]){ que.pop_back(); } //将该结点插入到队尾 que.push_back(i); } return results; }};","link":"/2021/11/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"根据前序和后序遍历构造二叉树","text":"题目描述​ 返回与给定的前序和后序遍历匹配的任何二叉树。 `pre` 和 ·post` 遍历中的值是不同的正整数。 示例12输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]输出：[1,2,3,4,5,6,7] 提示 1 &lt;= pre.length == post.length &lt;= 30 pre[] 和 post[] 都是 1, 2, …, pre.length 的排列 每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/ 思路 类型： 分治 实现：递归 须知知识点： 前序遍历顺序为中左右，后续遍历地顺序为左右中。 前序遍历的第一个结点和后续遍历的最后一个结点是对应的。可根据这个来判断左子树和右子树的长度。例如，对于上述示例pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]，可知pre[0]是根节点，pre[1]为左子树的根节点(这么说并不严谨，可看扩展知识。)，在post中的下标为2，因此左子树对应的后序遍历为post_l = [4,5,2]，可知左子树的长度为3，即可得到左子树的前序遍历为pre_l = [2,4,5] 。 流程：采取分治的思想，先建左子树和右子树，再将他们赋值给父节点的左右指针，难点为如何求得左子树的长度。 扩展知识：知道树的前序中序遍历或后序中序遍历都是可以唯一确定一个树。而只知道树的前序和后续遍历是无法唯一确定一棵树的，所以提示中说到” 如果有多个答案，可以返回其中一个“。 例如，将上述示例改为pre = [1,2,4,5,3,6,7], post = [4,5,3,6,7,2,1]，则1是根节点，而对于子树pre_ = [2,4,5,3,6,7], post_ = [4,5,3,6,7,2]，我们无法判断它是左子树还是右子树。 代码：c++1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { return creat(preorder, postorder, 0, preorder.size(), 0, postorder.size()); }/*函数输入参数：前序遍历，后序遍历，前序的初始结点，前序的最后结点+1，后序的初始结点，后序的初始结点+1输出参数：树的根节点*/ TreeNode* creat(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder, int perl, int perr, int postl, int postr){ if(perl == perr){ return NULL; //空树，返回空结点 } if (perl + 1 == perr){ return new TreeNode(preorder[perl]); //叶子节点，返回 } int the_val = preorder[perl]; TreeNode* head = new TreeNode(the_val); //建树的根节点 int i; for(i = postl; i &lt; postr - 1; i++){ if(postorder[i] == preorder[perl + 1]){ //preorder[perl + 1]为左子树根节点在前序遍历中的值，找其在后序遍历中对应的位置，进而确定左子树的长度。 break; } } int left = i - postl + 1; //左子树的长度 head-&gt;left = creat(preorder, postorder, perl + 1, perl + 1 + left, postl, postl + left); //生成左子树 head-&gt;right = creat(preorder, postorder, perl + left + 1, perr, postl + left, postr - 1); //生成右子树 return head; //返回该树的根结点 }};","link":"/2021/11/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"cuda","slug":"cuda","link":"/tags/cuda/"},{"name":"Pytorch","slug":"Pytorch","link":"/tags/Pytorch/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"字典树","slug":"字典树","link":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Pytorch","slug":"Pytorch","link":"/categories/Pytorch/"},{"name":"Matlab","slug":"Matlab","link":"/categories/Matlab/"},{"name":"每日一题","slug":"每日一题","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"动态规划","slug":"每日一题/动态规划","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字典树","slug":"每日一题/字典树","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"分治","slug":"每日一题/分治","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%86%E6%B2%BB/"}]}