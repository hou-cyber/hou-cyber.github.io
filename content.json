{"pages":[],"posts":[{"title":"Linux-cuda安装","text":"cuda install 查看机器的的Driver Version，根据下面网址选择适合的cuda版本 https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html 进入cuda 链接 : https://developer.nvidia.com/cuda-toolkit-archive ​ 下载好cuda，使用runfile（较简单）的安装方式。 ​ 进入下载好的文件夹，输入：sudo sh cuda_10.0.130_410.48_linux.run 接下来会有一个warning，这是因为我们装cuda的时候没有选择安装驱动，不用管即可。 环境配置： 打开bashrc文件： 1sudo gedit ~/.bashrc 文件中添加如下语句： 123export PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64\\ ${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 保存关闭后source文件使配置生效: 1source ~/.bashrc 安装检验 1nvcc --version cudnn install 进入cudnn的下载网址：https://developer.nvidia.com/cudnn 选择适合的版本并下载： 进入cudnn的下载目录，解压文件： 1tar -xzvf cudnn-x.x-linux-x64-v8.x.x.x.tgz 解压完成之后将得到一个cuda文件夹。在当前目录执行以下命令： 123$ sudo cp cuda/include/cudnn*.h /usr/local/cuda/include $ sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda/lib64 $ sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* cuda不同版本切换 首先将先前添加到.bashrc里的环境变量路径全部指向cuda软链接，也就是环境变量的路径里所有cuda-x.0的名字都改成cuda： 1sudo gedit ~/.bashrc 删除原来的软链接： 1sudo rm -rf /usr/local/cuda 创建新的软链接: 1sudo ln -s /usr/local/cuda-10.2 /usr/local/cuda 验证操作，查看新的软链接的指向内容： 1sudo stat /usr/local/cuda","link":"/2021/11/20/Linux-cuda%E5%AE%89%E8%A3%85/"},{"title":"Linux-分区","text":"分区介绍​ 由于硬盘仅仅为分区表保留了64个字节的存储空间，而每个分区的参数占据16个字节，故主引导扇区中总计只能存储4个分区的数据。也就是说，一块物理硬盘只能划分为4个主分区磁盘。在具体的应用中，4个主分区磁盘往往不能满足实际需求。为了建立更多的磁盘分区供操作系统使用，引入了扩展分区和逻辑分区，并把原来的分区类型称为主分区。 ​ linux操作系统中，存储接口接入的存储设备显示为sda, sdb, sdc等等。 一块物理硬盘只能有 一到四个主分区*(但其中只能有一个是活动的主分区),或一到三个主分区, 和一个扩展分区。分别对应sda1,sda2,sda3,sda4.* 扩展分区是不能使用的，它只是做为逻辑分区的容器存在的，先创建一个扩展分区，在扩展分区之上创建逻辑分区；所有的逻辑分区都是扩展分区的一部分。 硬盘的容量=主分区的容量+扩展分区的容量； 扩展分区的容量=各个逻辑分区的容量之和。 磁盘管理命令：fdisk n: 添加新的分区 p: 查看分区信息 w: 保存退出 q: 不保存退出 d: 删除分区 t: 改变分区类型 演示 查看分区 1234567891011121314151617181920hyh@ubuntu:~$ sudo fdisk /dev/sdcWelcome to fdisk (util-linux 2.31.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): pDisk /dev/sdc: 894.3 GiB, 960197124096 bytes, 1875385008 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: dosDisk identifier: 0x022a5ac1Device Boot Start End Sectors Size Id Type/dev/sdc1 2048 1875384319 1875382272 894.3G 83 Linux # Device 是分区名称 Boot 是否是启动分区 Start 起始的扇区 End 结束的扇区 #size显示分区的空间；ld 为分区类型的ID号 Type 为分区类型 创建分区 12345678910Command (m for help): n #新建分区Partition type #分区类型 p primary (0 primary, 0 extended, 4 free) #p---&gt;主分区 e extended (container for logical partitions) #e---&gt;扩展分区Select (default p): p #选择主分区Partition number (1-4, default 1): 1First sector (2048-1953525167, default 2048): #分区磁盘的起始位，默认值，回车就好！Last sector, +sectors or +size{K,M,G,T,P} (2048-1953525167, default 1953525167): +5G #磁盘大小选择，加号不能省略，回车即可Created a new partition 1 of type 'Linux' and of size 5 GiB. LVM介绍​ LVM全称为Logical Volume Management，它是Linux环境下对磁盘分区进行管理的一种机制，它通过在硬盘和分区上建立一个抽象的逻辑层，来屏蔽分区大小，磁盘空间给用户带来的困难。在LVM中，可以将多个磁盘分区组做成一个存储池，管理员可以在此存储池上随意创建逻辑卷组，再mount到相应的挂载点上去，从而达成动态增加磁盘空间的目的。 物理块（Physical Extent）: 物理区域，PV中可以用于分配的最小存储单元，可以在创建PV的时候制定（默认为4MB），如1M, 2M, 4M, 8M, 32M, 64M…组成同一VG中所有PV的PE大小应该相同。 物理卷（PhysicalVolume）： PV创建于块设备上，块设备可以是整个磁盘、标准的分区、RAID和Linux RAID设备。 磁盘分区只有成为物理卷才可以加入卷组。物理卷是LVM的基本存储块。 卷组（Volume Group）： 卷组，建立在PV之上，可以含有一个到多个PV。类似于内存存储池。 逻辑卷(Logical Volume)： LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷上边可以建立文件系统，用于mount到不同的挂载点，提升分区空间——这是真正跟用户打交道的部分。 LVM创建​ 1.创建PV：物理磁盘或分区被格式化为PV，空间被划分为一个个的PE ​ 2.创建VG：不同的PV加入到同一个VG中，不同PV的PE全部进入到了VG的PE池内 ​ 3.创建LV：LV基于PE创建，大小为PE的整数倍，组成LV的PE可能来自不同的物理磁盘 ​ 4.创建文件系统及挂载：LV现在就直接可以格式化后挂载使用了 ​ 另外，LV的扩充缩减实际上就是增加或减少组成该LV的PE数量，如果操作正确其过程不会丢失原始数据 LVM命令 安装LVM apt-get install lvm2 信息查看 lvmdiskscan #显示LVM可能管理的所有可用块存储设备 df -h #文件系统查看 pvs 或 pvdisplay #查看物理卷 vgs 或 vgdisplay #查看卷组 lvs 或 lvdisplay #查看逻辑卷 创建物理卷PV pvcreate /dev/sda1 /dev/sda2 (有多个磁盘分区直接在后面添加，各分区用空格隔开) 创建卷组VG并添加物理卷PV vgcreate testvg(卷组名称) /dev/sdb1 /dev/sdb2 (有多个物理卷，在后面直接加上，用空格隔开) 如果存在卷组，只需要把把物理卷加入卷组即可，如： vgextend testvg /dev/sdb3 在卷组上创建逻辑卷LV sudo lvcreate -L +12G -n lv-root ubuntu -L 参数后跟的是你要设定的逻辑卷大小，这个大小必须是是你设定的PE值的整数倍 -l 后面跟的是PE数量 -n 参数后跟逻辑卷名字，是对创建的卷组命名 最后跟的是卷组名 为创建好的逻辑卷创建文件系统 mkfs.ext4 /dev/testvg/lv-root 逻辑卷挂载 Linux下的文件系统需要被挂载后才能使用，我们创建一个空目录，再把创建好的逻辑卷挂载上就可以使用了。 mount /dev/testvg/lv-root /disk1 LVM的扩容 卷组的扩容 vgextend 逻辑卷的扩容 lvextend -L +1G /dev/testvg/lv-root vextend -l +100%FREE /dev/testvg/lv-root（将卷组中的剩余所有空闲空间扩展到逻辑卷） 更新文件系统 resize2fs /dev/testvg/lv-root 或在扩容逻辑卷的同时加上-r参数他会自动扩展文件系统大小 LVM的缩小 逻辑卷扩容可以在线操作但是缩减必须是离线执行 先卸载已挂载的逻辑卷，缩减后注意再次挂载 umount /disk1/ 缩小文件系统 resize2fs /dev/testvg/lv-root 1G 缩小逻辑卷 lvreduce -L -1G /dev/testvg/lv-root 缩小卷组 缩小VG卷组也就是把一个PV从卷组中移除，但我们要先肯定PV中没有数据，不然就会造成数据的丢失。 vgreduce testvg /dev/sdb3 移除物理卷 相当于让分区又重新变成了普通分区 pvremove /dev/sdb3 参考：https://blog.51cto.com/u_13438667/2084924","link":"/2021/11/25/Linux-%E5%88%86%E5%8C%BA/"},{"title":"Pytorch中的数据处理","text":"​ 在pytorch中，一般将torch.utils.data.Dataset和torch.utils.data.DataLoader搭配来提供训练和测试时的数据。 ​ 一般为，先创建一个torch.utils.data.Dataset对象，再将之传递给torch.utils.data.DataLoader来完成数据的iteration读取。 Dataset​ 在dataloader支持两种类型的dataset（map-style dataset，iterable-style dataset），我们用的一般都是第一种，意味着给出key值，能够返回对应的数据和标签。例如 访问dataset[idx]，就可以获取对应的image和label。 ​ 首先利用torch.utils.data.Dataset抽象类来定义自己的数据集，需要重写该类中的三个基本方法。 123__init__ 初始化，定义数据内容和标签;__getitem__ 得到数据内容和标签,即返回给你一组你要的数据（input,target）;__len__ 返回数据集的长度 DataLoader​ 构建可迭代的数据集装载器，可以理解为一个迭代器，每次返回一组（input,target）数据。 12345torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=None, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None, multiprocessing_context=None, generator=None, *, prefetch_factor=2, persistent_workers=False)其中，batch_size 批大小shuffle 每个epoch的数据是否需要重新调整数据drop_last 不足batch大小的最后部分是否舍去 ​ 每个epoch都会执行一次DataLoader，在执行DataLoader时，会进入到dataset中的__ getitem __方法来获得（input,target）。 数据处理​ DataLoader在读取数据时会调用dataset中的__ getitem __方法，所以一般对data的处理（比如归一化，剪裁，类型转化，数据增强，从图像变成tensor等）都是在该方法中进行。 123456789101112131415161718192021def __init__(self, image_root, gt_root, edge_root,trainsize): ....... self.augumentation = transforms.Compose([ transforms.RandomHorizontalFlip(), transforms.RandomVerticalFlip(), transforms.RandomRotation(degrees=(-180,180)) ])def __getitem__(self, index): ....... seed = np.random.randint(2147483647) # make a seed with numpy generator random.seed(seed) # apply this seed to img tranfsorms torch.manual_seed(seed) # needed for torchvision 0.7 image = self.augumentation(image) random.seed(seed) # apply this seed to target tranfsorms torch.manual_seed(seed) # needed for torchvision 0.7 gt = self.augumentation(gt) return image, gt ​ 正如上面的代码，一般会在__ getitem __ 方法中对数据进行增强处理，而增强方式（翻转、旋转等）会在__ init __方法中定义（主要使用torchvision.transforms中已写好的一些操作）。 ​ 需要注意的是为了input和label能够同步进行数据增强，需要使用 random.seed(seed)和torch.manual_seed(seed) 来设置随机数生成器的种子。 12345678910111213141516171819202122232425#random.seed(seed) 会使random.random() 每次生成的随机数是一样的&gt;&gt;&gt;random.seed(4)&gt;&gt;&gt;random.random()0.23604808973743452 #(1)&gt;&gt;&gt;random.random()0.1031660342307158 #(2)&gt;&gt;&gt;random.seed(4)&gt;&gt;&gt;random.random()0.23604808973743452 #结果与（1）相同&gt;&gt;&gt;random.random()0.1031660342307158 #结果与（2）相同#torch.manual_seed(seed) 会使torch.rand() 每次生成的随机数是一样的&gt;&gt;&gt;import torch&gt;&gt;&gt;torch.manual_seed(4)&lt;torch._C.Generator object at 0x00000191D60ABD10&gt;&gt;&gt;&gt;torch.rand(2)tensor([0.5596, 0.5591]) #（1）&gt;&gt;&gt;torch.rand(2)tensor([0.0915, 0.2100]) #（2）&gt;&gt;&gt;torch.manual_seed(4)&lt;torch._C.Generator object at 0x00000191D60ABD10&gt;&gt;&gt;&gt;torch.rand(4)tensor([0.5596, 0.5591, 0.0915, 0.2100]) #结果与[(1) (2)]相同 ​ 所以，为什么既要使用 random.seed(seed)，又要torch.manual_seed(seed) ？ 123456789101112131415161718192021class RandomHorizontalFlip(object): ..... def __call__(self, img): if torch.random() &lt; self.p: #不同版本torchvision可能不同 return F.hflip(img) return img class RandomVerticalFlip(object): ...... def __call__(self, img): if torch.random() &lt; self.p: #不同版本torchvision可能不同 return F.vflip(img) return imgclass RandomRotation(object): ...... def get_params(degrees): angle = random.uniform(degrees[0], degrees[1]) #使用的是random的随机函数 return angle","link":"/2021/11/24/Pytorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"title":"带限制的子序列和","text":"题目描述​ 给你一个整数数组 nums 和一个整数 k ，请你返回非空子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和~满足 i &lt; j 且 j - i &lt;= k 。 1数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 示例 示例1： 123输入：nums = [10,2,-10,5,20], k = 2输出：37解释：子序列为 [10, 2, 5, 20] 。 示例2： 123输入：nums = [-1,-2,-3], k = 1输出：-1解释：子序列必须是非空的，所以我们选择最大的数字。 示例3： 123输入：nums = [-1,-2,-3], k = 1输出：-1解释：子序列必须是非空的，所以我们选择最大的数字。 提示 1 &lt;= k &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 思路 类型：动态规划 + 单调队列优化 实现：循环、双向队列 分析：求子序列和的最大值，比较容易想到的是动态规划。建立数组dp，dp[i]表示以第i个元素结尾的子序列的最大值（注意：该子序列中要包含第i个元素）。状态转移方程为：$$dp[i]=\\max (dp[j])+nums[i]，其中 \\max(i-k, 0) \\leq j&lt;i$$需要注意的是只用动态规划会超时，既要进行优化。看状态转移方程发现，对于dp[i]每次要寻找前k个dp[j]的最大值，时间复杂度为k。因此，该题难点在于如何优化该寻找时间，这其实又是求滑动窗口最大值问题。 代码 c++ 动态规划：会超时。时间复杂度：O(nk) 1234567891011121314151617class Solution {public: int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) { if(nums.empty()){ return 0; //空数组，返回0 } vector&lt;int&gt; dp(nums.begin(), nums.end()); //建dp数组，用nums初始化，即刚开始最大值都为自己 int result = nums[0]; //记录dp数组中的最大值 for(int i = 1; i &lt; nums.size(); i++){ //求dp[1] -&gt; dp[max] for(int j = 1; j &lt;= k &amp;&amp; i - j &gt;= 0; j++){ //dp[i]状态转移方程 dp[i] = max(dp[i - j] + nums[i], dp[i]); } result = max(result, dp[i]); //更新result } return result; }}; 动态规划 + 单调队列优化 时间复杂度：O(n) 123456789101112131415161718192021222324252627282930class Solution {public: int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) { if(nums.empty()){ return 0; } vector&lt;int&gt; dp(nums.begin(), nums.end()); int result = nums[0]; deque&lt;int&gt; que; //建立双向队列 que.push_back(0); for(int i = 1; i &lt; nums.size(); i++){ while(i - que.front() &gt; k){ //若队首元素超过滑动窗口范围，pop que.pop_front(); } dp[i] = max(dp[que.front()] + nums[i], dp[i]); result = max(result, dp[i]); while(!que.empty() &amp;&amp; dp[i] &gt;= dp[que.back()]){ //若队尾元素小于dp[i]，pop que.pop_back(); } que.push_back(i); //将i插入队尾 } return result; }};","link":"/2021/11/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"},{"title":"滑动窗口最大值","text":"","link":"/2021/11/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"根据前序和后序遍历构造二叉树","text":"题目描述​ 返回与给定的前序和后序遍历匹配的任何二叉树。 `pre` 和 ·post` 遍历中的值是不同的正整数。 示例12输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]输出：[1,2,3,4,5,6,7] 提示 1 &lt;= pre.length == post.length &lt;= 30 pre[] 和 post[] 都是 1, 2, …, pre.length 的排列 每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/ 思路 类型： 分治 实现：递归 须知知识点： 前序遍历顺序为中左右，后续遍历地顺序为左右中。 前序遍历的第一个结点和后续遍历的最后一个结点是对应的。可根据这个来判断左子树和右子树的长度。例如，对于上述示例pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]，可知pre[0]是根节点，pre[1]为左子树的根节点(这么说并不严谨，可看扩展知识。)，在post中的下标为2，因此左子树对应的后序遍历为post_l = [4,5,2]，可知左子树的长度为3，即可得到左子树的前序遍历为pre_l = [2,4,5] 。 流程：采取分治的思想，先建左子树和右子树，再将他们赋值给父节点的左右指针，难点为如何求得左子树的长度。 扩展知识：知道树的前序中序遍历或后序中序遍历都是可以唯一确定一个树。而只知道树的前序和后续遍历是无法唯一确定一棵树的，所以提示中说到” 如果有多个答案，可以返回其中一个“。 例如，将上述示例改为pre = [1,2,4,5,3,6,7], post = [4,5,3,6,7,2,1]，则1是根节点，而对于子树pre_ = [2,4,5,3,6,7], post_ = [4,5,3,6,7,2]，我们无法判断它是左子树还是右子树。 代码：c++1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { return creat(preorder, postorder, 0, preorder.size(), 0, postorder.size()); }/*函数输入参数：前序遍历，后序遍历，前序的初始结点，前序的最后结点+1，后序的初始结点，后序的初始结点+1输出参数：树的根节点*/ TreeNode* creat(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder, int perl, int perr, int postl, int postr){ if(perl == perr){ return NULL; //空树，返回空结点 } if (perl + 1 == perr){ return new TreeNode(preorder[perl]); //叶子节点，返回 } int the_val = preorder[perl]; TreeNode* head = new TreeNode(the_val); //建树的根节点 int i; for(i = postl; i &lt; postr - 1; i++){ if(postorder[i] == preorder[perl + 1]){ //preorder[perl + 1]为左子树根节点在前序遍历中的值，找其在后序遍历中对应的位置，进而确定左子树的长度。 break; } } int left = i - postl + 1; //左子树的长度 head-&gt;left = creat(preorder, postorder, perl + 1, perl + 1 + left, postl, postl + left); //生成左子树 head-&gt;right = creat(preorder, postorder, perl + left + 1, perr, postl + left, postr - 1); //生成右子树 return head; //返回该树的根结点 }};","link":"/2021/11/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"Linux安装Matlab2020b","text":"linux安装Matlab2020b mkdir matlab2020 创建临时文件夹matlab2020 sudo mount -t auto -o loop Download/R2020a_Linux.iso matlab2020/ 挂载Downloade文件夹下的安装镜像R2020b_Linux.iso到创建的matlab2020文件夹下即可。 sudo ./matlab2020/install（即在matlab2020目录下执行sudo ./install）执行安装文件。中间需要输入用学校邮箱注册的账号密码，登录账户名一定要选工作站的用户名，不然后期要重新添加用户，中间/usr/local/bin/记得勾选上。安装时把工具包全选上 umount matlab2020/ #卸载光盘镜像 sudo rm -r matlab2020/ # 删除空文件夹 matlab在命令行直接输入matlab即可运行程序 12注：在进行第三步之前一定要联网，不然不会出现用学校邮箱登录画面。 第三部中的登录用户名一定要写自己的用户名(即Linux登录时的用户名)，因为只有这个指定的用户能用这个软件(即一个校园邮箱的激活码只能用于一个用户，其余方式的不清楚)，不过写错了也没关系，进行激活即可 若不能正常打开，进行激活账户cd /usr/local/MATLAB/R2020b/bin（即进入安装路径的bin目录） sh activate_matlab.sh ​ 若有多个matlab，可进入想要用的matlab的安装目录下的bin文件(默认安装目 录usr/local/MATLAB/R2020b)，执行 ./matlab(./的原因为防止他调用默认的matlab)。 gcc安装​ matlab下编译c文件，可在matwork上查找对应版本应该安装的gcc版本,要选择c++编译器时，要再安装g++(版本号最好和gcc一样，g++安装和gcc大同小异) 123sudo apt-get install gcc-4.8 安装4.8版本的gccsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100 将安装好的gcc版本放入gcc列表中，并设置优先级为100sudo update-alternatives --config gcc 将想用版本的gcc设置为默认gcc","link":"/2021/11/20/Linux%E5%AE%89%E8%A3%85Matlab2020b/"},{"title":"Linux-命令","text":"Linux 常用命令 chmod -R 777 /home/user 注：表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx chmod 777 /home/user 注：仅把/home/user目录的权限设置为rwxrwxrwx gedit 文件路径 注：以窗口形式打开文件 ifconfig 注：查看网络配置，windows下为ipconfig。 nautilus FloderName 打开指定目录的图形化窗口界面。 解压.zip 123unzip xxxxx.zip 把文件解压到当前目录下unzip file.zip -d destination_folder 把文件解压到指定的目录下(-d指定目标路径,file.zip是需要解压的，destination_folder是指定的目录下)。zip -r FileName.zip DirName 将指定目录下的所有文件和子目录一并压缩 挂载 12sudo mount /dev/sdb1 /mnt 挂载磁盘到某一路径sudo umount /dev/sdb1 卸载磁盘 进程 12ps -A 查看当前有哪些进程kill 5 位进程号 结束进程 用户 1234567sudo adduser username 新添加用户passwd username 修改密码sudo vim /etc/sudoers 赋予新用户 root 权限（找到root ALL=(ALL) ALL，在下一行添加username ALL=(ALL) ALL ）chmod u+rwx g+r o+r filename 用户添加读写运行权限，组成员添加读权限，其他用户添加读权限chmod a+w filename 所有用户添加写权限chmod 777 filename 所有用户添加读写运行权限 软件 12345678sudo apt-get upgrade 更新软件sudo apt-get install software-name 安装在软件库中的软件sudo apt-get remove 卸载软件sudo apt-get purge 卸载软件并删除配置文件sudo dpkg -i *.deb 安装 deb 软件dpkg -l 查看所有安装的软件sudo dpkg -i *.deb 安装 deb 软件dpkg -l 查看所有安装的软件 文件操作 123456789101112131415cd 切换目录，～为家目录，/为根目录，./为当前目录cd .. 切换到上级目录cd - 切换到上一次所在的目录pwd 查看当前所在目录ls 查看当前目录下的文件夹和文件名，-a显示隐藏文件，-l显示文件详细信息mkdir directory-name 新建文件夹rmdir directory-name 删除文件夹(必须为空)rm -rf directory-name 强制并递归删除文件夹cp src-file dst-file 复制文件mv src-file dst-file 移动文件ln -s src-file dst-file 建立软链接find path -name string 查找路经所在范围内满足字符串匹配的文件和目录cat filename 显示文件内容head -n 2 filename 显示文件前两行的内容tail -n 2 filename 显示文件末尾两行的内容 系统信息 123cat /proc/versionuname -asb_release -a","link":"/2021/11/23/Linux-%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"cuda","slug":"cuda","link":"/tags/cuda/"},{"name":"Pytorch","slug":"Pytorch","link":"/tags/Pytorch/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Pytorch","slug":"Pytorch","link":"/categories/Pytorch/"},{"name":"每日一题","slug":"每日一题","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matlab","slug":"Matlab","link":"/categories/Matlab/"},{"name":"动态规划","slug":"每日一题/动态规划","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"分治","slug":"每日一题/分治","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%86%E6%B2%BB/"}]}